#ifndef OC_SPAKE2PLUS_H
#define OC_SPAKE2PLUS_H

#include "mbedtls/bignum.h"
#include "mbedtls/ecp.h"

enum { kPubKeySize = 65 };

typedef struct
{
  mbedtls_mpi w0;
  mbedtls_ecp_point L;
  mbedtls_mpi y;
  mbedtls_ecp_point pub_y;
} spake_data_t;

#define SPAKE_CONTEXT "knxpase"

/**
 * @brief Initialize Spake2+
 *
 * @return int 0 on success
 */
int oc_spake_init(void);

/**
 * @brief Deinitialize Spake2+
 *
 * @return int 0 on success
 */
int oc_spake_free(void);

/**
 * @brief Verify the implementation of Spake2+ using the test vectors defined
 * within the spec.
 *
 * @return int 0 on successful self-test
 */
int oc_spake_test_vector();

/**
 * @brief Generate the fields needed for the PASE Parameter Exchange frame type.
 *
 * @ref oc_spake_init() must be called before this function can be used.
 *
 * @param rnd Random number
 * @param salt The salt to be used for PBKDF2
 * @param it The number of iterations to be used for PBKDF2
 * @return int 0 on success, mbedtls error code on failure
 */
int oc_spake_parameter_exchange(oc_string_t *rnd, oc_string_t *salt, int *it);

/**
 * @brief Get the currently set Spake2+ password
 *
 * @return Null-terminated string holding the password
 */
const char *oc_spake_get_password();

/**
 * @brief Set the Spake2+ password
 *
 * @param new_pass Null-terminated string containing the password
 */
void oc_spake_set_password(char *new_pass);

/**
 * @brief Calculate the w0 & w1 parameter
 *
 * Uses PBKDF2 with SHA256 & HMAC to calculate a 40-byte output which is
 * converted into w0 and w1.
 *
 * @param pw the null-terminated password
 * @param salt 32-byte array containing the salt
 * @param it the number of iterations to perform within PBKDF2
 * @param w0 the w0 parameter as defined by SPAKE2+. Must be initialized by the
 * caller.
 * @param L the L parameter as defined by SPAKE2+. Must be initialized by the
 * caller.
 * @return int 0 on success, mbedtls error code on failure
 */
int oc_spake_calc_w0_L(const char *pw, size_t len_salt, const uint8_t *salt,
                       int it, mbedtls_mpi *w0, mbedtls_ecp_point *L);

/**
 * @brief Generate an ECP keypair to be used within the Spake2+ handshake
 *
 * @param y The private part. Do not leak.
 * @param pub_y The public part.
 * @return int 0 on success, mbedtls error code on failure
 */
int oc_spake_gen_y(mbedtls_mpi *y, mbedtls_ecp_point *pub_y);

/**
 * @brief Calculate the Public Share of Party B, the KNX device
 *
 * @param pB Output public share
 * @param pubB Public key generated by Party B
 * @param w0 the w0 parameter, derived using the out-of-band secret
 */
int oc_spake_calc_pB(mbedtls_ecp_point *pB, const mbedtls_ecp_point *pubB,
                     const mbedtls_mpi *w0);

int oc_spake_encode_pubkey(mbedtls_ecp_point *P, uint8_t out[kPubKeySize]);

#endif // OC_SPAKE2PLUS_H